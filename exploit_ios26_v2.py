#!/usr/bin/env python3
"""
exploit_ios26.py - iOS 26.1 Security Research Tool for Pyto (v2)
Target: iPhone Air (iPhone18,4) / iOS 26.1

This version uses Rubicon-ObjC and safe Python APIs to avoid
code signing violations when accessing system functions.

Requirements:
- Pyto IDE on iOS
- Rubicon-ObjC (included in Pyto)

Author: Security Research Team
Date: January 2026
Version: 2.0 - Fixed ctypes crash on iOS 26.1
"""

import os
import sys
import time
import struct
import json

# ============================================================================
# Safe Imports (no ctypes for Mach functions)
# ============================================================================

print("[*] iOS 26.1 Security Research Tool v2.0")
print("[*] Loading modules...")

# ============================================================================
# Exploit State
# ============================================================================

class ExploitState:
    def __init__(self):
        self.device_info = {}
        self.process_info = {}
        self.services = {}
        self.iokit_services = {}
        self.leaked_addresses = []
        self.filesystem_access = {}
        self.capabilities = {}
        self.stage = 0
        
    def log(self, msg, level="*"):
        print(f"[{level}] {msg}")
        
    def log_success(self, msg):
        self.log(msg, "+")
        
    def log_error(self, msg):
        self.log(msg, "-")
        
    def log_info(self, msg):
        self.log(msg, "*")

g_state = ExploitState()

# ============================================================================
# Rubicon-ObjC Integration (Primary Method for Pyto)
# ============================================================================

def init_rubicon():
    """Initialize Rubicon-ObjC bridge"""
    g_state.log_info("Initializing Rubicon-ObjC bridge...")
    
    try:
        from rubicon.objc import ObjCClass, objc_method, NSObject
        from rubicon.objc.runtime import send_super, load_library
        
        g_state.log_success("Rubicon-ObjC loaded successfully")
        return True
        
    except ImportError as e:
        g_state.log_error(f"Rubicon-ObjC not available: {e}")
        g_state.log_info("Some features will be limited")
        return False

def get_device_info():
    """Get device information via UIDevice"""
    g_state.log_info("Getting device information...")
    
    try:
        from rubicon.objc import ObjCClass
        
        UIDevice = ObjCClass("UIDevice")
        device = UIDevice.currentDevice
        
        info = {
            "name": str(device.name),
            "systemName": str(device.systemName),
            "systemVersion": str(device.systemVersion),
            "model": str(device.model),
            "localizedModel": str(device.localizedModel),
            "userInterfaceIdiom": int(device.userInterfaceIdiom),
            "identifierForVendor": str(device.identifierForVendor),
        }
        
        for key, value in info.items():
            g_state.log_success(f"{key}: {value}")
        
        g_state.device_info = info
        return info
        
    except Exception as e:
        g_state.log_error(f"UIDevice failed: {e}")
        return None

def get_process_info():
    """Get process information via NSProcessInfo"""
    g_state.log_info("Getting process information...")
    
    try:
        from rubicon.objc import ObjCClass
        
        NSProcessInfo = ObjCClass("NSProcessInfo")
        process = NSProcessInfo.processInfo
        
        info = {
            "processName": str(process.processName),
            "processIdentifier": int(process.processIdentifier),
            "hostName": str(process.hostName),
            "operatingSystemVersionString": str(process.operatingSystemVersionString),
            "processorCount": int(process.processorCount),
            "activeProcessorCount": int(process.activeProcessorCount),
            "physicalMemory": int(process.physicalMemory),
            "systemUptime": float(process.systemUptime),
        }
        
        for key, value in info.items():
            g_state.log_success(f"{key}: {value}")
        
        g_state.process_info = info
        return info
        
    except Exception as e:
        g_state.log_error(f"NSProcessInfo failed: {e}")
        return None

def get_bundle_info():
    """Get bundle information"""
    g_state.log_info("Getting bundle information...")
    
    try:
        from rubicon.objc import ObjCClass
        
        NSBundle = ObjCClass("NSBundle")
        bundle = NSBundle.mainBundle
        
        info = {
            "bundlePath": str(bundle.bundlePath),
            "bundleIdentifier": str(bundle.bundleIdentifier) if bundle.bundleIdentifier else "N/A",
            "executablePath": str(bundle.executablePath) if bundle.executablePath else "N/A",
            "resourcePath": str(bundle.resourcePath) if bundle.resourcePath else "N/A",
        }
        
        # Get info dictionary
        info_dict = bundle.infoDictionary
        if info_dict:
            for key in ["CFBundleName", "CFBundleVersion", "CFBundleShortVersionString"]:
                try:
                    val = info_dict.objectForKey_(key)
                    if val:
                        info[key] = str(val)
                except:
                    pass
        
        for key, value in info.items():
            g_state.log_success(f"{key}: {value}")
        
        return info
        
    except Exception as e:
        g_state.log_error(f"NSBundle failed: {e}")
        return None

def query_mobile_gestalt():
    """Query MobileGestalt for device info"""
    g_state.log_info("Querying MobileGestalt...")
    
    try:
        from rubicon.objc import ObjCClass
        from rubicon.objc.runtime import load_library
        
        # Try to load MobileGestalt
        try:
            mg = load_library("/usr/lib/libMobileGestalt.dylib")
            g_state.log_success("MobileGestalt library loaded")
        except Exception as e:
            g_state.log_error(f"Cannot load MobileGestalt: {e}")
            return None
        
        # MobileGestalt queries (using NSString keys)
        NSString = ObjCClass("NSString")
        
        queries = [
            "ProductType",
            "HardwareModel", 
            "DeviceClass",
            "CPUArchitecture",
            "HasSEP",
            "ChipID",
            "BoardId",
            "BuildVersion",
            "ProductVersion",
            "DeviceName",
            "UserAssignedDeviceName",
            "RegionCode",
            "RegionInfo",
            "DeviceColor",
            "EnclosureColor",
            "DeviceEnclosureColor",
            "ReleaseType",
            "InternalBuild",
            "CarrierBundleInfoArray",
            "SupportedDeviceFamilies",
        ]
        
        # Note: Direct MGCopyAnswer call may not work in sandboxed apps
        # Try alternative approach via private frameworks
        g_state.log_info("MobileGestalt queries may be restricted in sandbox")
        
        return None
        
    except Exception as e:
        g_state.log_error(f"MobileGestalt query failed: {e}")
        return None

# ============================================================================
# File System Probing (Safe Python APIs)
# ============================================================================

def probe_filesystem():
    """Probe filesystem for interesting paths"""
    g_state.log_info("Probing filesystem...")
    
    interesting_paths = [
        # App sandbox
        ("App Home", os.path.expanduser("~")),
        ("App Documents", os.path.expanduser("~/Documents")),
        ("App Library", os.path.expanduser("~/Library")),
        ("App Caches", os.path.expanduser("~/Library/Caches")),
        ("App Preferences", os.path.expanduser("~/Library/Preferences")),
        ("Tmp", "/tmp"),
        
        # System paths (usually blocked)
        ("Root", "/"),
        ("Private", "/private"),
        ("Var", "/var"),
        ("Var/mobile", "/var/mobile"),
        ("Var/root", "/var/root"),
        ("Var/db", "/var/db"),
        ("Var/containers", "/var/containers"),
        ("Var/MobileDevice", "/var/MobileDevice"),
        
        # Interesting system files
        ("Passwd", "/etc/passwd"),
        ("Hosts", "/etc/hosts"),
        ("Fstab", "/etc/fstab"),
        ("Resolv.conf", "/etc/resolv.conf"),
        
        # System directories
        ("Applications", "/Applications"),
        ("System/Library", "/System/Library"),
        ("usr/bin", "/usr/bin"),
        ("usr/lib", "/usr/lib"),
        
        # Jailbreak indicators
        ("Cydia", "/Applications/Cydia.app"),
        ("Sileo", "/Applications/Sileo.app"),
        ("Zebra", "/Applications/Zebra.app"),
        ("Substitute", "/usr/lib/libsubstitute.dylib"),
        ("Substrate", "/Library/MobileSubstrate"),
        ("Checkra1n", "/var/checkra1n.dmg"),
        ("Unc0ver", "/private/var/containers/Bundle/unc0ver"),
        
        # Kernel/system
        ("Kernelcache", "/System/Library/Caches/com.apple.kernelcaches"),
        ("Dyld cache", "/System/Library/Caches/com.apple.dyld"),
        ("Dyld shared cache", "/System/Library/dyld"),
    ]
    
    results = {}
    
    for name, path in interesting_paths:
        try:
            if os.path.exists(path):
                if os.path.isdir(path):
                    try:
                        contents = os.listdir(path)
                        g_state.log_success(f"{name}: DIR ({len(contents)} items)")
                        results[name] = {"type": "dir", "items": len(contents), "path": path}
                        
                        # Show first few items for interesting directories
                        if len(contents) > 0 and len(contents) <= 20:
                            g_state.log_info(f"  Contents: {', '.join(contents[:10])}")
                            
                    except PermissionError:
                        g_state.log_success(f"{name}: DIR (no permission to list)")
                        results[name] = {"type": "dir", "accessible": False, "path": path}
                else:
                    try:
                        size = os.path.getsize(path)
                        g_state.log_success(f"{name}: FILE ({size} bytes)")
                        results[name] = {"type": "file", "size": size, "path": path}
                        
                        # Try to read small files
                        if size < 1024 and name in ["Passwd", "Hosts", "Resolv.conf"]:
                            try:
                                with open(path, 'r') as f:
                                    content = f.read()
                                    g_state.log_info(f"  Content: {content[:200]}")
                            except:
                                pass
                                
                    except:
                        g_state.log_success(f"{name}: FILE (size unknown)")
                        results[name] = {"type": "file", "path": path}
            else:
                g_state.log_error(f"{name}: not found")
                results[name] = {"exists": False, "path": path}
        except Exception as e:
            g_state.log_error(f"{name}: {e}")
            results[name] = {"error": str(e), "path": path}
    
    g_state.filesystem_access = results
    return results

def try_symlink_escape():
    """Try symlink-based sandbox escape"""
    g_state.log_info("Testing symlink escape vectors...")
    
    test_targets = [
        "/var/mobile",
        "/var/root",
        "/private/var/mobile/Library/Preferences",
        "/var/db/timezone",
        "/etc/passwd",
    ]
    
    # Find writable directory
    tmp_dirs = [
        os.path.expanduser("~/Documents/.exploit_test"),
        os.path.expanduser("~/tmp/.exploit_test"),
        "/tmp/.exploit_test",
    ]
    
    tmp_dir = None
    for d in tmp_dirs:
        try:
            os.makedirs(d, exist_ok=True)
            tmp_dir = d
            break
        except:
            continue
    
    if not tmp_dir:
        g_state.log_error("Cannot create test directory")
        return
    
    g_state.log_info(f"Using test directory: {tmp_dir}")
    
    for target in test_targets:
        link_name = f"link_{abs(hash(target)) % 0xFFFF:04x}"
        link_path = os.path.join(tmp_dir, link_name)
        
        try:
            # Remove existing
            if os.path.exists(link_path) or os.path.islink(link_path):
                os.unlink(link_path)
            
            # Create symlink
            os.symlink(target, link_path)
            
            # Try to access through symlink
            if os.path.exists(link_path):
                try:
                    if os.path.isdir(link_path):
                        contents = os.listdir(link_path)
                        g_state.log_success(f"SYMLINK ESCAPE: {target} -> {len(contents)} items!")
                        g_state.capabilities["symlink_escape"] = True
                    else:
                        with open(link_path, 'rb') as f:
                            data = f.read(100)
                            g_state.log_success(f"SYMLINK ESCAPE: {target} -> {len(data)} bytes!")
                            g_state.capabilities["symlink_escape"] = True
                except PermissionError:
                    g_state.log_error(f"Symlink to {target}: access denied")
                except Exception as e:
                    g_state.log_error(f"Symlink to {target}: {e}")
            else:
                g_state.log_error(f"Symlink to {target}: link not accessible")
            
            # Cleanup
            try:
                os.unlink(link_path)
            except:
                pass
                
        except Exception as e:
            g_state.log_error(f"Symlink to {target}: {e}")
    
    # Cleanup test directory
    try:
        os.rmdir(tmp_dir)
    except:
        pass

# ============================================================================
# Network Probing
# ============================================================================

def probe_network():
    """Probe network capabilities"""
    g_state.log_info("Probing network capabilities...")
    
    import socket
    
    # Test 1: DNS resolution
    try:
        ip = socket.gethostbyname("apple.com")
        g_state.log_success(f"DNS resolution works: apple.com -> {ip}")
        g_state.capabilities["dns"] = True
    except Exception as e:
        g_state.log_error(f"DNS resolution failed: {e}")
        g_state.capabilities["dns"] = False
    
    # Test 2: TCP connection
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect(("apple.com", 443))
        g_state.log_success("TCP connection works (apple.com:443)")
        sock.close()
        g_state.capabilities["tcp"] = True
    except Exception as e:
        g_state.log_error(f"TCP connection failed: {e}")
        g_state.capabilities["tcp"] = False
    
    # Test 3: Local socket
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.bind(("127.0.0.1", 0))
        port = sock.getsockname()[1]
        g_state.log_success(f"Local socket binding works (port {port})")
        sock.close()
        g_state.capabilities["local_socket"] = True
    except Exception as e:
        g_state.log_error(f"Local socket failed: {e}")
        g_state.capabilities["local_socket"] = False
    
    # Test 4: Unix domain socket
    sock_path = os.path.expanduser("~/Documents/.test_sock")
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(sock_path)
        g_state.log_success("Unix domain socket works")
        sock.close()
        os.unlink(sock_path)
        g_state.capabilities["unix_socket"] = True
    except Exception as e:
        g_state.log_error(f"Unix socket failed: {e}")
        g_state.capabilities["unix_socket"] = False
        try:
            os.unlink(sock_path)
        except:
            pass

# ============================================================================
# Memory Probing (Safe methods only)
# ============================================================================

def probe_memory():
    """Probe memory capabilities using safe methods"""
    g_state.log_info("Probing memory capabilities...")
    
    import mmap
    
    # Test 1: Anonymous mmap
    try:
        mm = mmap.mmap(-1, 4096)
        mm.write(b"EXPLOIT_TEST_DATA")
        mm.seek(0)
        data = mm.read(17)
        g_state.log_success(f"Anonymous mmap works: {data}")
        mm.close()
        g_state.capabilities["mmap"] = True
    except Exception as e:
        g_state.log_error(f"Anonymous mmap failed: {e}")
        g_state.capabilities["mmap"] = False
    
    # Test 2: Large allocation
    try:
        size = 100 * 1024 * 1024  # 100MB
        data = bytearray(size)
        g_state.log_success(f"Large allocation works: {size / (1024*1024):.0f} MB")
        del data
        g_state.capabilities["large_alloc"] = True
    except Exception as e:
        g_state.log_error(f"Large allocation failed: {e}")
        g_state.capabilities["large_alloc"] = False
    
    # Test 3: Memory info via resource module
    try:
        import resource
        usage = resource.getrusage(resource.RUSAGE_SELF)
        g_state.log_success(f"Max RSS: {usage.ru_maxrss / 1024:.2f} MB")
        g_state.log_success(f"User time: {usage.ru_utime:.2f}s")
        g_state.log_success(f"System time: {usage.ru_stime:.2f}s")
    except Exception as e:
        g_state.log_error(f"Resource usage failed: {e}")

# ============================================================================
# Process Probing (Safe methods only)
# ============================================================================

def probe_process():
    """Probe process capabilities"""
    g_state.log_info("Probing process capabilities...")
    
    # Basic process info
    g_state.log_success(f"PID: {os.getpid()}")
    g_state.log_success(f"PPID: {os.getppid()}")
    g_state.log_success(f"UID: {os.getuid()}")
    g_state.log_success(f"GID: {os.getgid()}")
    g_state.log_success(f"EUID: {os.geteuid()}")
    g_state.log_success(f"EGID: {os.getegid()}")
    
    # Check if root
    if os.getuid() == 0:
        g_state.log_success("Running as ROOT!")
        g_state.capabilities["root"] = True
    else:
        g_state.log_info("Not running as root")
        g_state.capabilities["root"] = False
    
    # Environment variables
    g_state.log_info("Interesting environment variables:")
    interesting_vars = ["HOME", "USER", "PATH", "TMPDIR", "SHELL", 
                        "DYLD_LIBRARY_PATH", "DYLD_INSERT_LIBRARIES",
                        "PYTHONPATH", "PYTHONHOME"]
    for var in interesting_vars:
        val = os.environ.get(var)
        if val:
            g_state.log_success(f"  {var}: {val[:100]}")
    
    # Test subprocess (likely blocked)
    g_state.log_info("Testing subprocess...")
    try:
        import subprocess
        result = subprocess.run(["/bin/ls", "/"], capture_output=True, timeout=5)
        if result.returncode == 0:
            g_state.log_success("Subprocess works!")
            g_state.log_info(f"  Root contents: {result.stdout.decode()[:200]}")
            g_state.capabilities["subprocess"] = True
        else:
            g_state.log_error(f"Subprocess failed: {result.stderr.decode()}")
            g_state.capabilities["subprocess"] = False
    except Exception as e:
        g_state.log_error(f"Subprocess blocked: {e}")
        g_state.capabilities["subprocess"] = False

# ============================================================================
# Keychain Probing (via Rubicon)
# ============================================================================

def probe_keychain():
    """Probe keychain access"""
    g_state.log_info("Probing keychain access...")
    
    try:
        from rubicon.objc import ObjCClass
        from rubicon.objc.runtime import load_library
        
        # Load Security framework
        try:
            security = load_library("/System/Library/Frameworks/Security.framework/Security")
            g_state.log_success("Security framework loaded")
        except:
            g_state.log_error("Cannot load Security framework")
            return
        
        # Note: Direct keychain access requires entitlements
        g_state.log_info("Keychain access requires proper entitlements")
        g_state.log_info("App sandbox restricts keychain to app's own items")
        
    except Exception as e:
        g_state.log_error(f"Keychain probe failed: {e}")

# ============================================================================
# IOKit Probing (via Rubicon - safer than ctypes)
# ============================================================================

def probe_iokit_via_rubicon():
    """Probe IOKit services via Rubicon"""
    g_state.log_info("Probing IOKit services...")
    
    try:
        from rubicon.objc.runtime import load_library
        
        # Load IOKit
        try:
            iokit = load_library("/System/Library/Frameworks/IOKit.framework/IOKit")
            g_state.log_success("IOKit framework loaded")
        except Exception as e:
            g_state.log_error(f"Cannot load IOKit: {e}")
            return
        
        # Note: Direct IOKit calls may trigger code signing issues
        # Just report that the framework is available
        g_state.log_info("IOKit is available but direct calls may be restricted")
        g_state.capabilities["iokit"] = True
        
    except Exception as e:
        g_state.log_error(f"IOKit probe failed: {e}")
        g_state.capabilities["iokit"] = False

# ============================================================================
# URL Scheme Probing
# ============================================================================

def probe_url_schemes():
    """Probe available URL schemes"""
    g_state.log_info("Probing URL schemes...")
    
    try:
        from rubicon.objc import ObjCClass
        
        UIApplication = ObjCClass("UIApplication")
        NSURL = ObjCClass("NSURL")
        
        app = UIApplication.sharedApplication
        
        schemes = [
            "tel://",
            "sms://",
            "mailto://",
            "facetime://",
            "facetime-audio://",
            "maps://",
            "music://",
            "videos://",
            "itms://",
            "itms-apps://",
            "cydia://",
            "sileo://",
            "filza://",
            "ssh://",
            "sftp://",
            "prefs://",
            "App-prefs://",
            "shortcuts://",
            "workflow://",
            "x-apple-health://",
            "calshow://",
            "x-apple-reminder://",
        ]
        
        for scheme in schemes:
            try:
                url = NSURL.URLWithString_(scheme)
                if url and app.canOpenURL_(url):
                    g_state.log_success(f"{scheme}: available")
                else:
                    g_state.log_error(f"{scheme}: not available")
            except:
                g_state.log_error(f"{scheme}: error checking")
                
    except Exception as e:
        g_state.log_error(f"URL scheme probe failed: {e}")

# ============================================================================
# Clipboard Probing
# ============================================================================

def probe_clipboard():
    """Probe clipboard access"""
    g_state.log_info("Probing clipboard access...")
    
    try:
        from rubicon.objc import ObjCClass
        
        UIPasteboard = ObjCClass("UIPasteboard")
        pasteboard = UIPasteboard.generalPasteboard
        
        # Check if we can read
        try:
            content = pasteboard.string
            if content:
                g_state.log_success(f"Clipboard read: {str(content)[:50]}...")
            else:
                g_state.log_info("Clipboard is empty or not text")
            g_state.capabilities["clipboard_read"] = True
        except:
            g_state.log_error("Clipboard read blocked")
            g_state.capabilities["clipboard_read"] = False
        
        # Check if we can write
        try:
            test_string = "EXPLOIT_TEST_CLIPBOARD"
            pasteboard.string = test_string
            g_state.log_success("Clipboard write works")
            g_state.capabilities["clipboard_write"] = True
        except:
            g_state.log_error("Clipboard write blocked")
            g_state.capabilities["clipboard_write"] = False
            
    except Exception as e:
        g_state.log_error(f"Clipboard probe failed: {e}")

# ============================================================================
# Main Runner
# ============================================================================

def print_banner():
    """Print exploit banner"""
    banner = """
╔═══════════════════════════════════════════════════════════════╗
║       iOS 26.1 Security Research Tool for Pyto (v2.0)         ║
║                                                               ║
║  Target: iPhone Air (iPhone18,4)                              ║
║  iOS Version: 26.1                                            ║
║                                                               ║
║  This version uses safe APIs to avoid code signing crashes    ║
║  WARNING: For authorized security research only!              ║
╚═══════════════════════════════════════════════════════════════╝
"""
    print(banner)

def run_all_probes():
    """Run all security probes"""
    print_banner()
    
    stages = [
        ("Initialize Rubicon-ObjC", init_rubicon),
        ("Get Device Info", get_device_info),
        ("Get Process Info", get_process_info),
        ("Get Bundle Info", get_bundle_info),
        ("Query MobileGestalt", query_mobile_gestalt),
        ("Probe Filesystem", probe_filesystem),
        ("Try Symlink Escape", try_symlink_escape),
        ("Probe Network", probe_network),
        ("Probe Memory", probe_memory),
        ("Probe Process", probe_process),
        ("Probe Keychain", probe_keychain),
        ("Probe IOKit", probe_iokit_via_rubicon),
        ("Probe URL Schemes", probe_url_schemes),
        ("Probe Clipboard", probe_clipboard),
    ]
    
    results = {}
    
    for stage_name, stage_func in stages:
        print(f"\n{'='*60}")
        print(f"Stage: {stage_name}")
        print('='*60)
        
        try:
            start_time = time.time()
            result = stage_func()
            elapsed = time.time() - start_time
            
            results[stage_name] = {
                "success": True,
                "time": elapsed,
                "result": result
            }
            print(f"\n[✓] {stage_name} completed in {elapsed:.2f}s")
            
        except Exception as e:
            results[stage_name] = {
                "success": False,
                "error": str(e)
            }
            print(f"\n[✗] {stage_name} failed: {e}")
            import traceback
            traceback.print_exc()
    
    # Print summary
    print("\n" + "="*60)
    print("SUMMARY")
    print("="*60)
    
    print(f"\nDevice Info:")
    for key, value in g_state.device_info.items():
        print(f"  {key}: {value}")
    
    print(f"\nProcess Info:")
    for key, value in list(g_state.process_info.items())[:5]:
        print(f"  {key}: {value}")
    
    print(f"\nCapabilities:")
    for cap, available in g_state.capabilities.items():
        status = "✓" if available else "✗"
        print(f"  [{status}] {cap}")
    
    print(f"\nFilesystem Access: {len(g_state.filesystem_access)} paths tested")
    accessible = sum(1 for v in g_state.filesystem_access.values() 
                     if isinstance(v, dict) and v.get("type"))
    print(f"  Accessible: {accessible}")
    
    print("\n" + "="*60)
    print("Security research complete!")
    print("="*60)
    
    return results

# ============================================================================
# Entry Point
# ============================================================================

if __name__ == "__main__":
    try:
        results = run_all_probes()
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
    except Exception as e:
        print(f"\n[!] Fatal error: {e}")
        import traceback
        traceback.print_exc()
